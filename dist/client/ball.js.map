{"version":3,"sources":["../src/client/ball.ts"],"names":[],"mappings":"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","file":"ball.js","sourcesContent":["/**************************************************************************\r\n  NOTE: Take a look at ball-animation-concept.svg/.png to get a better\r\n        understanding of the calculation logic of the ball movement.\r\n        This code has not been optimized for size or speed. It was written\r\n        with ease of understanding in mind.\r\n**************************************************************************/\r\nwindow.addEventListener(\"load\", async () => {\r\n    /** Represents a 2d point */\r\n    interface Point {\r\n      x: number;\r\n      y: number\r\n    };\r\n    \r\n    /** Represents the size of a 2d object */\r\n    interface Size {\r\n      width: number;\r\n      height: number;\r\n    }\r\n    \r\n    /** Represents directions  */\r\n    enum Direction { top, right, bottom, left };\r\n  \r\n    // Get some information about the browser window and the ball. This information will\r\n    // never change. So it makes sense to get it only once to make the rest of the program faster.\r\n    const ball = document.getElementById('ball');\r\n    const ballSize: Size = { width: ball.clientWidth, height: ball.clientHeight };\r\n    const ballHalfSize = splitSize(ballSize, 2);\r\n    const clientSize: Size = { width: document.documentElement.clientWidth, height: document.documentElement.clientHeight };\r\n    const clientHalfSize = splitSize(clientSize, 2);\r\n  \r\n    // Move ball to center of the screen\r\n    let ballCurrentPosition: Point = { x: clientHalfSize.width, y: clientHalfSize.height };\r\n    moveBall(ballCurrentPosition);\r\n  \r\n    // Calculate the random angle that the ball should initially travel.\r\n    // Should be an angle between 27.5 and 45 DEG (=PI/8 and PI/4 RAD)\r\n    const angle = Math.PI / 8 + Math.random() * Math.PI / 8;\r\n  \r\n    // Calculate the random quadrant into which the ball should initially travel.\r\n    // 0 = upper right, 1 = lower right, 2 = lower left, 3 = upper left\r\n    let quadrant = Math.floor(Math.random() * 4);\r\n  \r\n    do {\r\n      // Calculate target.\r\n      // X-coordinate iw either right or left border of browser window (depending on\r\n      //              target quadrant)\r\n      // y-coordinate is calculated using tangens angle function of angle\r\n      //              (note: tan(angle) = delta-y / delta-x). The sign depends on\r\n      //              the target quadrant)\r\n      const targetX = (quadrant === 0 || quadrant === 1) ? clientSize.width - ballSize.width : 0;\r\n      const targetBallPosition: Point = {\r\n        x: targetX,\r\n        y: ballCurrentPosition.y + Math.tan(angle) * Math.abs(targetX - ballCurrentPosition.x) * ((quadrant === 0 || quadrant === 3) ? -1 : 1)\r\n      };\r\n  \r\n      // Animate ball to calculated target position\r\n      const borderTouch = await animateBall(ballCurrentPosition, targetBallPosition);\r\n  \r\n      // Based on where the ball touched the browser window, we change the new target quadrant.\r\n      // Note that in this solution the angle stays the same.\r\n      switch (borderTouch.touchDirection) {\r\n        case Direction.left: \r\n          quadrant = (quadrant === 2) ? 1 : 0;\r\n          break;\r\n        case Direction.right:\r\n          quadrant = (quadrant === 0) ? 3 : 2;\r\n          break;\r\n        case Direction.top:\r\n          quadrant = (quadrant === 0) ? 1 : 2;\r\n          break;\r\n        case Direction.bottom:\r\n          quadrant = (quadrant === 2) ? 3 : 0;\r\n          break;\r\n        default:\r\n          throw new Error('Invalid direction, should never happen');\r\n      }\r\n  \r\n      // The touch position is the new current position of the ball.\r\n      // Note that we fix the position here slightly in case a small piece of the ball has reached an area\r\n      // outside of the visible browser window.\r\n      ballCurrentPosition.x = Math.min(Math.max(borderTouch.touchPosition.x - ballHalfSize.width, 0) + ballHalfSize.width, clientSize.width);\r\n      ballCurrentPosition.y = Math.min(Math.max(borderTouch.touchPosition.y - ballHalfSize.height, 0) + ballHalfSize.height, clientSize.height);\r\n    } while (true); // Forever\r\n  \r\n    /**\r\n     * Animate the ball from the current position to the target position. Stops\r\n     * animation if border of browser window is reached.\r\n     * @returns Position and direction where ball touched the border of the browser window\r\n     *          at the end of the animation\r\n     */\r\n    function animateBall(currentBallPosition: Point, targetBallPosition: Point): Promise<{touchPosition: Point, touchDirection: Direction}> {\r\n      // Calculate x and y distances from current to target position\r\n      const distanceToTarget: Size = subtractPoints(targetBallPosition, currentBallPosition);\r\n  \r\n      // Use Pythagoras to calculate distance from current to target position\r\n      const distance = Math.sqrt(distanceToTarget.width * distanceToTarget.width + distanceToTarget.height * distanceToTarget.height);\r\n  \r\n      // Variable defining the speed of the animation (pixels that the ball travels per interval)\r\n      const pixelsPerInterval = 1;\r\n  \r\n      // Calculate distance per interval\r\n      const distancePerInterval = splitSize(distanceToTarget, distance * pixelsPerInterval);\r\n  \r\n      // Return a promise that will resolve when animation is done\r\n      return new Promise<{touchPosition: Point, touchDirection: Direction}>(res => {\r\n        // Start at current ball position\r\n        let animatedPosition: Point = currentBallPosition;\r\n  \r\n        // Move point every 4ms\r\n        const interval = setInterval(() => {\r\n          // Move animated position by the distance it has to travel per interval\r\n          animatedPosition = movePoint(animatedPosition, distancePerInterval);\r\n  \r\n          // Move the ball to the new position\r\n          moveBall(animatedPosition);\r\n  \r\n          // Check if the ball touches the browser window's border\r\n          let touchDirection: Direction;\r\n          if ((animatedPosition.x - ballHalfSize.width) < 0) { touchDirection = Direction.left; }\r\n          if ((animatedPosition.y - ballHalfSize.height) < 0) { touchDirection = Direction.top; }\r\n          if ((animatedPosition.x + ballHalfSize.width) > clientSize.width) { touchDirection = Direction.right; }\r\n          if ((animatedPosition.y + ballHalfSize.height) > clientSize.height) { touchDirection = Direction.bottom; }\r\n  \r\n          if (touchDirection !== undefined) {\r\n            // Ball touches border -> stop animation\r\n            clearInterval(interval);\r\n            res({ touchPosition: animatedPosition, touchDirection: touchDirection });\r\n          }\r\n        }, 4);\r\n      });\r\n    }\r\n  \r\n    /** Move the center of the ball to given position **/\r\n    function moveBall(targetPosition: Point): void {\r\n        // Note the 'px' at the end of the coordinates for CSS. Don't\r\n        // forget it. Without the 'px', it doesn't work.\r\n        const leftPos = `${targetPosition.x - ballHalfSize.width}px`;\r\n        const topPos = `${targetPosition.y - ballHalfSize.height}px`;\r\n  \r\n        if (ball.style.left !== leftPos) {\r\n          ball.style.setProperty('left', leftPos);\r\n        }\r\n  \r\n        if (ball.style.top !== topPos) {\r\n          ball.style.setProperty('top', topPos);\r\n        }\r\n    }\r\n  \r\n    /** Subtracts two points and returns the size between them */\r\n    function subtractPoints(a: Point, b: Point): Size {\r\n      return {\r\n        width: a.x - b.x,\r\n        height: a.y - b.y\r\n      };\r\n    }\r\n  \r\n    /** Moves a point by the given size */\r\n    function movePoint(p: Point, s: Size): Point {\r\n      return {\r\n        x: p.x + s.width,\r\n        y: p.y + s.height\r\n      };\r\n    }\r\n  \r\n    /** Divides the width and height of the given size by the given divider */\r\n    function splitSize(s: Size, divider: number): Size {\r\n      return {\r\n        width: s.width / divider,\r\n        height: s.height / divider\r\n      };\r\n    }\r\n  });"]}